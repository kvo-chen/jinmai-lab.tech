# 粒子艺术品牌形状优化方案

## 目标
让粒子组成特定品牌形状，如狗不理包子的包子形状，增强津门老字号文化的视觉呈现。

## 实现思路
1. **扩展粒子模型类型**：添加品牌特定形状（如包子）
2. **实现形状生成函数**：使用几何方法创建品牌形状
3. **优化粒子分布**：让粒子更集中地形成特定形状
4. **保持现有功能兼容**：不破坏现有粒子系统的功能

## 具体实现步骤

### 1. 更新粒子模型类型定义
- 在 `particleModels.ts` 中扩展 `ParticleModelType` 类型，添加 `'baozi'`（包子）等品牌形状
- 更新相关接口和类型定义

### 2. 实现品牌形状生成函数
- **包子形状**：使用旋转的椭圆和曲线组合生成包子轮廓
- **其他品牌形状**：预留扩展接口，便于添加更多津门老字号品牌形状

### 3. 更新粒子系统配置
- 在 `ParticleSystem.tsx` 中更新粒子配置类型，支持新的品牌形状
- 确保粒子池和缓存机制支持新的模型类型

### 4. 优化粒子分布算法
- 实现基于形状轮廓的粒子分布
- 让粒子在形状内部更密集，边缘更清晰
- 添加形状变形动画，增强视觉效果

### 5. 更新组件接口
- 更新 `ParticleSystemContainer` 组件，支持选择品牌形状
- 确保与现有代码兼容

## 技术实现细节

### 包子形状生成
```typescript
// 生成包子形状
static generateBaozi(config: ParticleModelConfig): THREE.BufferGeometry {
  const { size } = config;
  const geometry = new THREE.BufferGeometry();
  const vertices: number[] = [];
  
  const segments = 32;
  const radius = size * 0.5;
  const height = size * 0.8;
  
  // 包子底部（圆形）
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    const x = Math.cos(t) * radius;
    const y = -height / 2;
    const z = Math.sin(t) * radius;
    vertices.push(x, y, z);
  }
  
  // 包子顶部（曲线）
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    const x = Math.cos(t) * radius * 0.8;
    const y = Math.cos(t * 2) * height / 4 + height / 4;
    const z = Math.sin(t) * radius * 0.8;
    vertices.push(x, y, z);
  }
  
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  return geometry;
}
```

### 粒子分布优化
- 实现基于形状的粒子生成算法
- 让粒子在形状内部随机分布，边缘区域粒子更密集
- 添加粒子向形状中心的吸引力，保持形状完整性

## 预期效果
- 粒子能够清晰地组成包子等品牌形状
- 保持良好的性能和流畅度
- 支持与现有粒子行为模式结合使用
- 提供品牌形状选择接口，便于扩展更多品牌

## 兼容性考虑
- 保持与现有代码的完全兼容
- 新功能作为可选扩展，不影响现有功能
- 确保在不同设备上都能正常运行

## 后续扩展
- 支持基于图像的粒子形状生成
- 添加更多津门老字号品牌形状
- 实现粒子形状动画过渡效果
- 支持用户自定义形状