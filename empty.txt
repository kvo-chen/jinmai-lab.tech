<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势控制 3D 粒子系统</title>
    
    <!-- 引入 Tailwind CSS 样式框架 -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 引入 Three.js 3D 渲染库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- 引入 MediaPipe Hands & Camera Utils 用于手势识别 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- 引入 Font Awesome 图标库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        
        /* 摄像头预览窗口样式 */
        #camera-preview {
            transform: scaleX(-1); /* 镜像翻转，使手势更自然 */
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        /* 自定义颜色选择器样式 */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; }

        /* 下拉选择器样式 */
        #shape-selector {
            appearance: none; /* 移除默认样式 */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%239CA3AF'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd' /%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            padding-right: 2rem;
        }


        /* 加载动画 */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* 模态窗口样式 - 突出科幻感 */
        .anomaly-modal {
            background-color: rgba(10, 25, 45, 0.9);
            border: 2px solid #3b82f6;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
        }
        /* 威胁等级颜色定义 */
        .threat-critical { color: #f87171; }
        .threat-high { color: #fbbf24; }
        .threat-medium { color: #34d399; }
        .threat-low { color: #60a5fa; }
    </style>
</head>
<body class="text-white">

    <!-- 加载遮罩层 -->
    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black transition-opacity duration-500">
        <div class="loader mb-4"></div>
        <h2 class="text-xl font-light tracking-widest text-blue-400">正在初始化神经系统...</h2>
        <p class="text-sm text-gray-500 mt-2">请允许摄像头权限以启用手势控制</p>
    </div>

    <!-- UI 控制层 -->
    <div class="absolute top-0 left-0 w-full p-6 flex justify-between items-start z-10 pointer-events-none">
        
        <!-- 左上角标题与状态 -->
        <div class="pointer-events-auto">
            <h1 class="text-3xl font-bold tracking-tighter bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500 drop-shadow-lg">
                NEBULA FLOW
            </h1>
            <div class="flex items-center gap-2 mt-2">
                <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500"></div>
                <span id="status-text" class="text-xs text-gray-400 uppercase tracking-widest">等待摄像头...</span>
            </div>
            <p class="text-xs text-gray-500 mt-1 max-w-xs leading-relaxed">
                当前尺度因子: <span id="scale-readout" class="text-blue-300 font-bold">1.00</span>
            </p>
        </div>

        <!-- 右上角控制面板 -->
        <div class="flex flex-col gap-4 pointer-events-auto bg-black/40 backdrop-blur-md p-4 rounded-2xl border border-white/10 shadow-xl transition-all hover:bg-black/60">
            
            <!-- 粒子形状选择器 (新增) -->
            <div class="group flex items-center justify-between gap-4">
                <span class="text-sm text-gray-300 font-medium"><i class="fas fa-shapes mr-2"></i>粒子形状</span>
                <select id="shape-selector" class="bg-white/10 text-white text-xs py-1.5 pl-2 pr-8 rounded-lg cursor-pointer border border-white/20">
                    <option value="galaxy">星系漩涡 (默认)</option>
                    <option value="shibajie_mahua">十八街麻花 (Braid)</option>
                    <option value="goubuli_baozi">狗不理包子 (Baozi)</option>
                    <option value="eryeyan_zhagao">耳朵眼炸糕 (Zhagao)</option>
                    <option value="darentang">达仁堂药丸 (Pill)</option>
                    <option value="yangliuqing">杨柳青年画 (Painting)</option>
                    <option value="kite">风筝魏 (Kite)</option>
                    <option value="clay_figure">泥人张 (Clay Figure)</option>
                </select>
            </div>
            
            <!-- 颜色选择器 -->
            <div class="group flex items-center justify-between gap-4">
                <span class="text-sm text-gray-300 font-medium"><i class="fas fa-palette mr-2"></i>粒子颜色</span>
                <input type="color" id="color-picker" value="#00ffff" title="选择粒子颜色">
            </div>

            <!-- Gemini LLM 功能按钮 -->
            <button id="generate-report-btn" onclick="generateAnomalyReport()" class="flex items-center justify-center w-full py-2 px-3 bg-purple-500/20 hover:bg-purple-500/30 rounded-lg text-sm transition-colors border border-purple-400/50 text-purple-300 font-bold">
                <i class="fas fa-microchip mr-2"></i> ✨ 生成异常报告
            </button>

            <!-- 全屏按钮 -->
            <button id="fullscreen-btn" class="flex items-center justify-center w-full py-2 bg-white/10 hover:bg-white/20 rounded-lg text-sm transition-colors">
                <i class="fas fa-expand mr-2"></i> 全屏沉浸
            </button>
        </div>
    </div>

    <!-- 摄像头预览 (左下角) -->
    <div class="absolute bottom-6 left-6 z-10 pointer-events-auto">
        <div class="relative group">
            <video id="input-video" class="w-32 h-24 object-cover hidden"></video> <!-- 原始视频隐藏，只用于计算 -->
            <canvas id="camera-preview" class="w-40 h-32 bg-black/50"></canvas>
            <div class="absolute bottom-1 left-1 bg-black/60 px-2 py-0.5 rounded text-[10px] text-gray-300 backdrop-blur-sm">
                视觉传感器
            </div>
        </div>
    </div>

    <!-- WebGL 画布 -->
    <canvas id="webgl-canvas" class="block w-full h-full"></canvas>

    <!-- 异常报告模态窗口 -->
    <div id="report-modal" class="hidden fixed inset-0 z-40 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm transition-opacity duration-300">
        <div id="report-content" class="anomaly-modal p-8 w-full max-w-xl rounded-xl text-sm transition-transform duration-300">
            <h3 class="text-xl font-bold mb-4 border-b border-blue-400/50 pb-2 flex justify-between items-center text-blue-300">
                <i class="fas fa-exclamation-triangle mr-2"></i> ANOMALY REPORT
            </h3>
            <div id="report-output" class="space-y-4">
                <p class="text-gray-400 text-center"><i class="fas fa-circle-notch fa-spin mr-2"></i> 正在分析数据流...</p>
            </div>
            <button onclick="document.getElementById('report-modal').classList.add('hidden')" class="mt-6 w-full py-2 bg-red-500/10 hover:bg-red-500/20 rounded-lg text-red-300 text-xs font-bold uppercase border border-red-500/30">
                DISMISS [确认解除]
            </button>
        </div>
    </div>

    <script>
        /**
         * 状态管理与全局变量
         */
        const state = {
            targetScale: 1.0,  // 目标缩放值（由手势控制）
            currentScale: 1.0, // 当前平滑过渡的缩放值
            baseColor: new THREE.Color(0x00ffff),
            handsDetected: false,
            isLoaded: false
        };

        // 粒子系统相关全局变量 (稍后在初始化函数中赋值)
        let particlesMesh;
        let coreMesh;
        let material;
        let currentShape = 'galaxy';

        // 颜色主题配置 
        const COLOR_THEMES = {
            'galaxy': { hex: '#00ffff', name: '宇宙青色' }, 
            'kite': { hex: '#ff4500', name: '烈焰红' },     // 风筝魏
            'shibajie_mahua': { hex: '#ffcc00', name: '金黄焦糖' }, // 十八街麻花
            'clay_figure': { hex: '#a0522d', name: '陶土棕' },// 泥人张
            'goubuli_baozi': { hex: '#ccffcc', name: '嫩绿蒸汽' },   // 狗不理包子
            'yangliuqing': { hex: '#4169e1', name: '宝蓝色' },// 杨柳青年画
            'eryeyan_zhagao': { hex: '#ffc72c', name: '金黄琥珀' }, // 耳朵眼炸糕 (New)
            'darentang': { hex: '#8b0000', name: '古朴朱红' }  // 达仁堂 (New)
        };


        // 形状配置常量
        const SHAPE_CONFIG = {
            particlesCount: 8000, // 粒子数量
            size: 50 // 粒子分布范围
        };

        // DOM 元素
        const canvas = document.getElementById('webgl-canvas');
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('camera-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const scaleReadout = document.getElementById('scale-readout');
        const shapeSelector = document.getElementById('shape-selector');


        /**
         * Three.js 场景初始化
         */
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));


        /**
         * 粒子形状生成函数
         */
        function createParticleGeometry(shape) {
            const particlesCount = SHAPE_CONFIG.particlesCount;
            const posArray = new Float32Array(particlesCount * 3);
            const randomArray = new Float32Array(particlesCount);
            
            for(let i = 0; i < particlesCount; i++) {
                const index = i * 3;
                let x, y, z;
                
                if (shape === 'kite') {
                    // 风筝魏 (Kite): 简单的平面菱形或十字结构
                    const scale = 15;
                    const r = Math.random(); 
                    
                    // 优化: 增加厚度 (Z-thickness)
                    const kiteThickness = 2.0; 

                    if (r < 0.15) { // 模拟中心支架 (Y轴)
                        x = (Math.random() - 0.5) * 1;
                        y = (Math.random() - 0.5) * scale * 1.5;
                        z = (Math.random() - 0.5) * kiteThickness; // 使用新厚度
                    } else if (r < 0.3) { // 模拟横向支架 (X轴)
                        x = (Math.random() - 0.5) * scale * 2;
                        y = (Math.random() - 0.5) * 1;
                        z = (Math.random() - 0.5) * kiteThickness; // 使用新厚度
                    } else { // 填充菱形轮廓
                        x = (Math.random() - 0.5) * scale * 2;
                        y = (Math.random() - 0.5) * scale * 1.5;
                        z = (Math.random() - 0.5) * kiteThickness; // 使用新厚度
                        
                        // 约束为菱形边界
                        if (Math.abs(x) / (scale * 1.0) + Math.abs(y) / (scale * 0.75) > 1.0) {
                            x *= 0.5;
                            y *= 0.5;
                        }
                    }

                } else if (shape === 'shibajie_mahua') {
                    // 十八街麻花 (Mahua): 扭曲的 Helix/Torus 结构
                    const R = 8; // Coil radius
                    const r_cross = 2; // Cross-section radius
                    const twist = 3; // Number of twists
                    const t = Math.random() * Math.PI * 4; // Angle along the coil (4 * Pi for two full twists)
                    const u = Math.random() * Math.PI * 2; // Angle around the cross-section
                    
                    // 螺旋线基础坐标
                    const base_x = R * Math.cos(t);
                    const base_y = R * Math.sin(t);
                    const base_z = t * 2; // Z increases with t

                    // 应用截面和扭曲
                    const twisted_u = u + t * twist * 0.1; // 随着 t 增加，横截面角度扭转
                    
                    x = base_x + r_cross * Math.cos(twisted_u);
                    y = base_y + r_cross * Math.sin(twisted_u);
                    z = base_z - 15; // 居中

                } else if (shape === 'clay_figure') {
                    // 泥人张 (Clay Figure): 模拟人体形状的扁平化水滴形
                    const radius = 12;
                    const r = Math.pow(Math.random(), 1/3) * radius;
                    const u = Math.random() * 2 * Math.PI;
                    let v = Math.acos(Math.random() * 2 - 1);
                    
                    x = r * Math.sin(v) * Math.cos(u) * 0.8; // 略微扁平
                    y = r * Math.cos(v) * 1.5; // 沿Y轴拉伸，增加躯干感
                    z = r * Math.sin(v) * Math.sin(u) * 0.8; 
                    
                    // 稍微偏移重心，模拟站立姿势
                    y = y - 5; 

                } else if (shape === 'goubuli_baozi') {
                     // 狗不理包子 (Baozi): 顶部褶皱的球体形状
                    const radius = 10;
                    const r = Math.pow(Math.random(), 1/3) * radius;
                    const u = Math.random() * Math.PI * 2;
                    let v = Math.acos(Math.random() * 2 - 1);
                    
                    // 偏置点到上半球 (模拟顶部褶皱)
                    if (Math.random() < 0.6) {
                         v = Math.acos(Math.random() * 0.5 + 0.5); // 偏向 Z+ 轴
                    }
                    
                    x = r * Math.sin(v) * Math.cos(u);
                    y = r * Math.sin(v) * Math.sin(u);
                    z = r * Math.cos(v); // Z轴是高度
                    
                    // 轻微的“提褶”效果
                    if (z > 0) z *= 1.1; 
                
                } else if (shape === 'yangliuqing') {
                    // 杨柳青年画 (Painting): 矩形平面结构
                    const width = 20;
                    const height = 15;
                    // 优化: 增加厚度 (Thickness)
                    const thickness = 4; // 增加厚度从 1 到 4

                    // 均匀分布在矩形平面内
                    x = (Math.random() - 0.5) * width;
                    y = (Math.random() - 0.5) * height;
                    z = (Math.random() - 0.5) * thickness;
                
                } else if (shape === 'eryeyan_zhagao') {
                    // 耳朵眼炸糕 (Zhagao): 扁圆球形/椭圆体
                    const radius = 10;
                    const r = Math.pow(Math.random(), 1/3) * radius;
                    const u = Math.random() * 2 * Math.PI;
                    const v = Math.acos(Math.random() * 2 - 1);

                    // 沿 Y 轴（高度）压缩，形成扁平状
                    const heightFactor = 0.6; 
                    
                    x = r * Math.sin(v) * Math.cos(u);
                    y = r * Math.cos(v) * heightFactor; 
                    z = r * Math.sin(v) * Math.sin(u);

                } else if (shape === 'darentang') {
                    // 达仁堂 (Darentang): 紧密的圆形药丸
                    const radius = 8;
                    // 确保粒子密集地分布在球体内部，模拟实心的蜡丸
                    const r = Math.pow(Math.random(), 1/3) * radius; 
                    const u = Math.random() * 2 * Math.PI;
                    const v = Math.acos(Math.random() * 2 - 1);
                    
                    x = r * Math.sin(v) * Math.cos(u);
                    y = r * Math.cos(v);
                    z = r * Math.sin(v) * Math.sin(u);

                } else { // 'galaxy' (Default/Original logic)
                    // 星系漩涡：螺旋分布
                    const distance = Math.pow(Math.random(), 3) * 25 + 5;
                    const angle = Math.random() * Math.PI * 2;
                    const armOffset = (Math.random() - 0.5) * 5;
                    
                    x = distance * Math.cos(angle) + armOffset;
                    y = (Math.random() - 0.5) * 5;
                    z = distance * Math.sin(angle);
                    
                    const spiralAngle = angle * 2;
                    x += Math.cos(spiralAngle) * 2;
                    z += Math.sin(spiralAngle) * 2;
                }

                posArray[index] = x;
                posArray[index + 1] = y;
                posArray[index + 2] = z;
                
                randomArray[i] = Math.random();
            }

            const newGeometry = new THREE.BufferGeometry();
            newGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            newGeometry.setAttribute('aRandom', new THREE.BufferAttribute(randomArray, 1));
            return newGeometry;
        }

        function initializeParticles(shapeName) {
            // 清理旧网格
            if (particlesMesh) {
                scene.remove(particlesMesh);
                particlesMesh.geometry.dispose();
            }
            if (coreMesh) {
                scene.remove(coreMesh);
                coreMesh.geometry.dispose();
            }
            
            currentShape = shapeName;

            // --- 1. 获取并设置颜色主题 ---
            const theme = COLOR_THEMES[shapeName] || COLOR_THEMES['galaxy'];
            const newColor = new THREE.Color(theme.hex);
            state.baseColor.set(newColor);
            document.getElementById('color-picker').value = theme.hex;
            // -----------------------------
            
            const newGeometry = createParticleGeometry(shapeName);
            
            // 如果材质不存在，则创建材质 (只在第一次运行时)
            if (!material) {
                const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
                material = new THREE.PointsMaterial({
                    size: 0.2,
                    map: sprite,
                    transparent: true,
                    color: state.baseColor,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    opacity: 0.8
                });
            }

            // --- 2. 更新材质颜色 ---
            material.color.set(newColor);
            // -------------------------
            
            // 重新创建粒子网格
            particlesMesh = new THREE.Points(newGeometry, material);
            scene.add(particlesMesh);

            // 重新创建核心
            const coreRadius = (shapeName === 'galaxy' || shapeName === 'goubuli_baozi') ? 1 : (shapeName === 'darentang' ? 0.8 : 0.2); 
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: newColor, // 使用新颜色
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const coreGeometry = new THREE.SphereGeometry(coreRadius, 32, 32);
            coreMesh = new THREE.Mesh(coreGeometry, coreMaterial);
            scene.add(coreMesh);
            
            // 调整相机位置以适应不同形状
            if (shapeName === 'shibajie_mahua') {
                camera.position.set(0, 0, 45); 
                camera.rotation.x = 0;
            } else if (shapeName === 'kite') {
                // 优化: 调整相机视角，更明显地看到深度
                camera.position.set(0, 0, 35); // 稍微后退
                camera.rotation.x = -0.3; // 俯视角度
            } else if (shapeName === 'yangliuqing') {
                 // 优化: 调整相机视角，更明显地看到深度
                camera.position.set(0, 0, 30);
                camera.rotation.x = -0.5; // 明显俯视角度
            } else if (shapeName === 'eryeyan_zhagao') {
                 camera.position.set(0, 0, 30);
                 camera.rotation.x = -0.1; 
            } else if (shapeName === 'darentang') {
                 camera.position.set(0, 0, 25); // 稍微靠近
                 camera.rotation.x = 0;
            }
            else {
                camera.position.set(0, 0, 30);
                camera.rotation.x = 0;
            }
            
            // 重置尺度、旋转和FOV
            state.targetScale = 1.0;
            state.currentScale = 1.0;
            camera.fov = 75; // 重置 FOV
            camera.updateProjectionMatrix();
            particlesMesh.rotation.set(0, 0, 0);
        }

        // --- 初始化粒子系统 ---
        initializeParticles('galaxy');
        // --- 初始化粒子系统 ---


        /**
         * MediaPipe Hands 初始化与逻辑
         */
        function onResults(results) {
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handsDetected = true;
                updateStatus(true);

                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                    drawLandmarks(previewCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
                }

                let newScale = 1.0;

                if (results.multiHandLandmarks.length === 2) {
                    // 双手控制缩放 (Pinch-to-Zoom like)
                    const hand1 = results.multiHandLandmarks[0][9]; // 手指中部的关键点
                    const hand2 = results.multiHandLandmarks[1][9];
                    
                    const distance = Math.sqrt(
                        Math.pow(hand1.x - hand2.x, 2) + 
                        Math.pow(hand1.y - hand2.y, 2)
                    );
                    
                    // 距离越远，缩放越大
                    newScale = Math.max(0.5, Math.min(distance * 4, 5.0));
                
                } else if (results.multiHandLandmarks.length === 1) {
                    // 单手捏合控制缩放
                    const landmarks = results.multiHandLandmarks[0];
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];

                    const pinchDistance = Math.sqrt(
                        Math.pow(thumbTip.x - indexTip.x, 2) + 
                        Math.pow(thumbTip.y - indexTip.y, 2)
                    );

                    // 捏合距离越小，缩放越大 (反向逻辑，模拟抓取)
                    newScale = Math.max(0.5, Math.min(3.0 - pinchDistance * 3.5, 3.0));
                }

                state.targetScale = newScale;

            } else {
                state.handsDetected = false;
                updateStatus(false);
                // 没有手势时，保持微弱的呼吸动画
                state.targetScale = 1.0 + Math.sin(Date.now() * 0.001) * 0.05; 
            }
            previewCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        
        cameraUtils.start()
            .then(() => {
                loadingScreen.classList.add('opacity-0');
                setTimeout(() => loadingScreen.remove(), 500);
            })
            .catch(err => {
                console.error("Camera error:", err);
                statusText.innerText = "摄像头访问失败";
                statusDot.classList.replace('bg-red-500', 'bg-gray-500');
                loadingScreen.classList.add('opacity-0');
                setTimeout(() => loadingScreen.remove(), 500);
            });


        /**
         * 动画循环
         */
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // 1. 平滑插值 (Lerp) 更新缩放，使变化平稳
            // --- 优化：降低 Lerp 因子 (0.2 -> 0.08) 减缓手势响应速度，让缩放更平滑 ---
            state.currentScale += (state.targetScale - state.currentScale) * 0.08; 

            // 2. 应用缩放到粒子系统
            if (particlesMesh) {
                // 仅缩放粒子系统的几何结构，让粒子在 3D 空间内移动
                particlesMesh.scale.setScalar(state.currentScale); 
            }
            
            // 3. 增强视觉冲击力
            if (material) {
                const scaleFactor = state.currentScale; 
                
                // 粒子尺寸保持固定 (根据用户要求)
                material.size = 0.2; 
                
                // 动态调整粒子不透明度：放大时更亮
                material.opacity = Math.min(1.0, 0.5 + Math.max(0, (scaleFactor - 1.0)) * 1.0); 
            }

            // 调整核心的亮度和大小
            if (coreMesh && coreMesh.material) {
                // 核心亮度更剧烈地随尺度增加
                coreMesh.material.opacity = Math.min(1.0, 0.3 + (state.currentScale - 1.0) * 1.0);
                // 核心膨胀得更明显
                coreMesh.scale.setScalar(state.currentScale * 0.8);
            }
            
            // 4. 调整相机 FOV，模拟冲刺进入/离开感
            // 增加最大 FOV 变化 (50) 并使用平方函数，实现非线性、更具爆发性的视觉变化
            const maxFovShift = 50; 
            const fovInfluence = Math.pow(Math.max(0, state.currentScale - 1.0), 2); // 放大时增长更快
            const targetFov = 75 + fovInfluence * maxFovShift;
            
            // --- 优化：降低 FOV Lerp 因子 (0.2 -> 0.1) 减缓相机视野变化速度 ---
            camera.fov += (targetFov - camera.fov) * 0.1; 
            camera.updateProjectionMatrix();

            // 5. 粒子自转/公转 (增强特色动画)
            if (particlesMesh) {
                // --- 优化：整体降低旋转速度 ---
                const slowFactor = 0.4; // 统一的慢速乘数
                
                if (currentShape === 'shibajie_mahua') {
                    // 麻花绕 Y 轴旋转
                    particlesMesh.rotation.y = elapsedTime * 0.15; // 0.4 -> 0.15
                    particlesMesh.rotation.x = Math.sin(elapsedTime * 0.5) * 0.2;
                } else if (currentShape === 'kite') {
                    // 风筝魏：绕 Z 轴旋转，模拟飞行时的摇摆
                    particlesMesh.rotation.z = elapsedTime * 0.08; // 0.2 -> 0.08
                    particlesMesh.rotation.x = Math.sin(elapsedTime * 0.5) * 0.3;
                } else if (currentShape === 'yangliuqing') {
                    // 年画：缓慢绕Y轴旋转
                    particlesMesh.rotation.y = elapsedTime * 0.02; // 0.05 -> 0.02
                    particlesMesh.rotation.x = -0.5 + Math.sin(elapsedTime * 0.2) * 0.05; 
                } else if (currentShape === 'goubuli_baozi') {
                    // 包子：绕 X 轴和 Z 轴缓慢旋转
                    particlesMesh.rotation.x = elapsedTime * 0.03; // 0.08 -> 0.03
                    particlesMesh.rotation.z = Math.sin(elapsedTime * 0.3) * 0.1;
                } else if (currentShape === 'eryeyan_zhagao') {
                    // 炸糕：简单、均匀的滚动
                    particlesMesh.rotation.y = elapsedTime * 0.05; // 0.15 -> 0.05
                    particlesMesh.rotation.z = Math.sin(elapsedTime * 0.2) * 0.05; // 0.15 -> 0.05
                } else if (currentShape === 'darentang') {
                    // 达仁堂：极慢且稳重的旋转
                    particlesMesh.rotation.y = elapsedTime * 0.01; // 0.02 -> 0.01
                    particlesMesh.rotation.x = elapsedTime * 0.005; // 0.01 -> 0.005
                } else {
                    // 默认旋转 (星系/泥人张)
                    particlesMesh.rotation.y = elapsedTime * 0.02; // 0.05 -> 0.02
                    particlesMesh.rotation.x = elapsedTime * 0.01; // 0.02 -> 0.01
                }
            }


            // 6. 更新 UI 读数
            scaleReadout.innerText = state.currentScale.toFixed(2);

            renderer.render(scene, camera);
        }

        animate();

        /**
         * LLM 异常报告生成器功能 (Gemini API 集成)
         */

        // 获取当前粒子颜色
        function getCurrentHexColor() {
            return `#${state.baseColor.getHexString()}`;
        }
        
        // Gemini API 配置
        const apiKey = ""; // 保持为空，运行时将自动填充
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // 包含指数退避策略的 Fetch 函数
        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) { // Too Many Requests
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function generateAnomalyReport() {
            const button = document.getElementById('generate-report-btn');
            const modal = document.getElementById('report-modal');
            const output = document.getElementById('report-output');

            // 锁定按钮并显示加载状态
            button.disabled = true;
            button.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> 正在生成报告...';
            output.innerHTML = '<p class="text-gray-400 text-center"><i class="fas fa-circle-notch fa-spin mr-2"></i> 正在分析数据流...</p>';
            modal.classList.remove('hidden');

            const scaleFactor = state.currentScale.toFixed(2);
            const colorHex = getCurrentHexColor();

            // 获取形状的中文名称
            const shapeNameCn = shapeSelector.options[shapeSelector.selectedIndex].text.split(' ')[0];

            // System Instruction：定义 AI 角色和输出格式
            const systemInstruction = "你是一位专业的星际分析员，专注于编写简洁、正式、具有科幻风格的异常报告。你的报告必须基于提供的参数并严格遵守给定的JSON格式。";

            // 根据尺度因子和形状定义状态
            let scaleType;
            if (scaleFactor > 2.0) {
                scaleType = "极度膨胀 (Extreme Expansion)";
            } else if (scaleFactor > 1.2) {
                scaleType = "快速膨胀 (Rapid Expansion)";
            } else if (scaleFactor < 0.7) {
                scaleType = "引力坍缩 (Gravitational Collapse)";
            } else {
                scaleType = "系统稳定 (System Stability)";
            }

            // 用户查询：提供给 AI 的上下文数据，加入形状信息
            const userQuery = `分析当前粒子系统的状态并生成异常报告。
            当前粒子形态: ${shapeNameCn}
            当前尺度因子 (Scale Factor): ${scaleFactor}
            粒子主要颜色 (Primary Color): ${colorHex}
            尺度类型 (Scale Type): ${scaleType}
            
            请根据这些参数，创建一个异常标题、一个不超过60字的中文描述，并确认威胁等级。`;
            
            // API Payload 配置：使用 JSON 结构化输出
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "anomaly_title_cn": { "type": "STRING", "description": "富有科幻感的中文异常标题" },
                            "anomaly_title_en": { "type": "STRING", "description": "对应的英文标题" },
                            "threat_level": { "type": "STRING", "description": "威胁等级，必须是：CRITICAL, HIGH, MEDIUM, 或 LOW" },
                            "description_cn": { "type": "STRING", "description": "基于参数的中文报告描述，不超过60字" }
                        },
                        "propertyOrdering": ["anomaly_title_cn", "anomaly_title_en", "threat_level", "description_cn"]
                    }
                }
            };

            try {
                // 调用 Gemini API
                const result = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    const jsonString = candidate.content.parts[0].text;
                    const report = JSON.parse(jsonString);

                    // 根据威胁等级设置 CSS 类
                    let threatClass;
                    switch (report.threat_level.toUpperCase()) {
                        case 'CRITICAL': threatClass = 'threat-critical'; break;
                        case 'HIGH': threatClass = 'threat-high'; break;
                        case 'MEDIUM': threatClass = 'threat-medium'; break;
                        case 'LOW': threatClass = 'threat-low'; break;
                        default: threatClass = 'text-gray-400';
                    }

                    // 渲染报告内容
                    output.innerHTML = `
                        <div class="space-y-2">
                            <p class="text-xs text-gray-500 uppercase">TITLE / 标题</p>
                            <p class="text-lg font-bold text-white">${report.anomaly_title_cn} <span class="text-gray-400 font-normal ml-2 text-sm">(${report.anomaly_title_en})</span></p>
                        </div>
                        <div class="flex justify-between border-t border-b border-white/10 py-3 mt-4 text-xs font-mono">
                            <div>THREAT LEVEL: <span class="${threatClass} font-bold">${report.threat_level.toUpperCase()}</span></div>
                            <div>SHAPE / 形态: <span class="text-white">${shapeNameCn}</span></div>
                            <div>SCALE FACTOR: <span class="text-white">${scaleFactor}</span></div>
                        </div>
                        <div class="mt-4">
                            <p class="text-xs text-gray-500 uppercase mb-2">MISSION LOG / 任务日志</p>
                            <p class="text-base text-gray-300 leading-relaxed">${report.description_cn}</p>
                        </div>
                    `;
                } else {
                    output.innerHTML = '<p class="text-red-400 text-center"><i class="fas fa-bug mr-2"></i> 报告系统故障：数据解析失败。</p>';
                }
            } catch (error) {
                console.error("Gemini API Error:", error);
                output.innerHTML = `<p class="text-red-400 text-center"><i class="fas fa-times-circle mr-2"></i> CRITICAL ERROR: 无法连接到分析核心。</p>`;
            } finally {
                // 恢复按钮状态
                button.disabled = false;
                button.innerHTML = '<i class="fas fa-microchip mr-2"></i> ✨ 生成异常报告';
            }
        }


        /**
         * 事件监听与 UI 交互
         */

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 颜色选择器
        document.getElementById('color-picker').addEventListener('input', (e) => {
            const color = new THREE.Color(e.target.value);
            state.baseColor.set(color); 
            if (material) material.color.set(color);
            if (coreMesh && coreMesh.material) coreMesh.material.color.set(color);
        });
        
        // 形状选择器 (监听器)
        shapeSelector.addEventListener('change', (e) => {
            initializeParticles(e.target.value);
        });


        // 全屏切换
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            const btn = document.getElementById('fullscreen-btn');
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen()
                    .then(() => {
                        btn.innerHTML = '<i class="fas fa-compress mr-2"></i> 退出全屏';
                    })
                    .catch(err => {
                        console.warn("当前环境禁止全屏 API:", err);
                    });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen()
                        .then(() => {
                            btn.innerHTML = '<i class="fas fa-expand mr-2"></i> 全屏沉浸';
                        })
                        .catch(err => console.warn("退出全屏失败:", err));
                }
            }
        });

        // 状态更新 UI 辅助函数
        function updateStatus(isDetected) {
            if (isDetected) {
                statusDot.classList.replace('bg-red-500', 'bg-green-500');
                statusDot.classList.replace('bg-gray-500', 'bg-green-500'); 
                statusDot.classList.add('animate-pulse');
                statusText.innerText = "信号已链接";
                statusText.classList.add('text-green-400');
            } else {
                statusDot.classList.replace('bg-green-500', 'bg-red-500');
                statusDot.classList.remove('animate-pulse');
                statusText.innerText = "搜索手势信号...";
                statusText.classList.remove('text-green-400');
            }
        }

        // 初始化预览画布大小
        previewCanvas.width = 320;
        previewCanvas.height = 240;

    </script>
</body>
</html>